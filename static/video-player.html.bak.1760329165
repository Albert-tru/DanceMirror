<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>è§†é¢‘å¯¹æ¯”æ’­æ”¾å™¨ - DanceMirror</title>
    <link rel="stylesheet" href="/static/css/common.css">
    <link rel="stylesheet" href="/static/css/video-player.css">
    <style>
        .compare-container { display:flex; gap:20px; margin:20px 0; align-items:flex-start; }
        .video-box { flex:1; display:flex; flex-direction:column; }
        .video-box h3 { margin:0 0 10px 0; padding:10px; background:linear-gradient(135deg,#667eea 0%,#764ba2 100%); color:#fff; border-radius:8px; text-align:center; }
        .video-box video { width:100%; background:#000; border-radius:8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .record-controls { margin-top:12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
        .record-timer { margin-left:8px; padding:6px 12px; background:#f0f0f0; border-radius:4px; font-family:monospace; font-size:14px; font-weight:bold; color:#e74c3c; }
        .sync-controls { background:#f8f9fa; padding:15px; border-radius:8px; margin:15px 0; }
        .offset-control { display:flex; gap:10px; align-items:center; margin-top:10px; }
        .offset-control label { font-weight:600; min-width:200px; }
        .offset-control input[type="range"] { flex:1; min-width:200px; }
        .offset-control input[type="number"] { width:80px; padding:5px; border:1px solid #ddd; border-radius:4px; text-align:center; }
        .master-controls { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px; }
        @media (max-width:768px) { .compare-container { flex-direction:column; } }
        .recording-indicator { display:inline-block; width:10px; height:10px; background:#e74c3c; border-radius:50%; margin-right:5px; animation:blink 1s infinite; }
        @keyframes blink { 0%,50%{opacity:1}51%,100%{opacity:0.3} }
        .video-box video.mirrored { transform: scaleX(-1); }
        /* æ¨¡å¼åˆ‡æ¢ */
        .mode-switcher { text-align:center; margin:12px 0; }
        .mode-switcher .btn { margin:0 6px; }
        /* è£å‰ªé¢æ¿ */
        .crop-panel { position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); background:#fff; padding:16px; border-radius:8px; box-shadow:0 10px 30px rgba(0,0,0,0.2); z-index:10000; width:90%; max-width:900px; max-height:85vh; overflow:auto; }
        .crop-preview { position:relative; margin-top:12px; }
        #cropCanvas { width:100%; background:#000; border-radius:6px; display:block; }
        .preset-ratios { display:flex; gap:8px; flex-wrap:wrap; }
        .ratio-btn { padding:8px 12px; border:1px solid #ddd; background:#fff; border-radius:6px; cursor:pointer; }
        .ratio-btn.active { background:#007bff; color:#fff; border-color:#007bff; }
        .crop-actions { margin-top:12px; text-align:center; }
        .crop-close { position:absolute; right:12px; top:8px; cursor:pointer; font-weight:bold; }
        .hidden { display:none !important; }
    </style>
</head>
<body>
    <div class="container">
        <a href="/static/index.html" class="nav-link">â† è¿”å›é¦–é¡µ</a>
        <h1>ğŸ¬ è§†é¢‘å¯¹æ¯”æ’­æ”¾å™¨ï¼ˆå½•åˆ¶ & è£å‰ª & åŒæ­¥ï¼‰</h1>
        <p class="subtitle">å·¦ä¾§è§‚çœ‹åŸè§†é¢‘ï¼Œå³ä¾§å½•åˆ¶æˆ–åŠ è½½æœ¬åœ°è§†é¢‘è¿›è¡Œå¯¹æ¯”ã€‚å½•åˆ¶ç»“æŸåå¯è£å‰ªä¸ºå¸¸è§æ¯”ä¾‹ï¼ˆç¤ºä¾‹ä½¿ç”¨ Canvasï¼Œå¯¼å‡ºå›¾ç‰‡ï¼›å¯é›†æˆ ffmpeg.wasm ç”Ÿæˆè§†é¢‘ï¼‰ã€‚</p>
        <div class="message" id="message"></div>

        <div class="mode-switcher">
            <button id="singleModeBtn" class="btn btn-primary">ğŸ“º å•è§†é¢‘æ¨¡å¼</button>
            <button id="comparisonModeBtn" class="btn">ğŸ¬ åŒå±å¯¹ç…§æ¨¡å¼</button>
        </div>

        <div id="singleVideoContainer" class="video-container hidden">
            <h3>ğŸ“º å•è§†é¢‘è§‚çœ‹</h3>
            <video id="singleVideo" controls crossorigin="anonymous"></video>
            <div style="margin-top:8px;">
                <h4 id="singleVideoTitle"></h4>
                <p id="singleVideoDesc" style="color:#666;"></p>
            </div>
        </div>

        <div class="compare-container" id="comparisonContainer">
            <div class="video-box">
                <h3>ğŸ“º åŸè§†é¢‘ï¼ˆä¸»æ§ï¼‰</h3>
                <video id="originalVideo" controls crossorigin="anonymous"></video>
                <div class="video-info" style="margin-top:10px;">
                    <h4 id="videoTitle" style="margin:5px 0;">è¯·é€‰æ‹©è§†é¢‘</h4>
                    <p id="videoDescription" style="margin:5px 0; color:#666; font-size:13px;">æš‚æ— æè¿°</p>
                </div>
            </div>

            <div class="video-box">
                <h3>ğŸ¥ ä½ çš„å½•åˆ¶ / æœ¬åœ°è§†é¢‘</h3>
                <video id="userVideo" controls muted></video>
                <div class="record-controls">
                    <button id="startRecBtn" class="btn btn-success">ğŸ”´ å¼€å§‹å½•åˆ¶</button>
                    <button id="stopRecBtn" class="btn btn-secondary" disabled>â¹ï¸ åœæ­¢å½•åˆ¶</button>

                    <input id="localVideoInput" type="file" accept="video/*" class="hidden"/>
                    <button id="uploadLocalBtn" class="btn">ğŸ“ åŠ è½½æœ¬åœ°è§†é¢‘</button>

                    <button id="downloadRecBtn" class="btn" disabled>ğŸ’¾ ä¸‹è½½</button>
                    <button id="uploadRecBtn" class="btn" disabled>â˜ï¸ ä¸Šä¼ </button>
                    <span class="record-timer" id="recTimer">0:00</span>
                </div>
            </div>
        </div>

        <div class="sync-controls">
            <h3>ğŸ›ï¸ åŒæ­¥æ§åˆ¶</h3>
            <div class="master-controls">
                <button class="btn" id="masterPlay">â–¶ï¸ æ’­æ”¾</button>
                <button class="btn" id="masterPause">â¸ï¸ æš‚åœ</button>
                <button class="btn" id="masterRestart">â®ï¸ é‡æ–°å¼€å§‹</button>
            </div>
            <div class="offset-control">
                <label>â±ï¸ åŒæ­¥åç§»ï¼ˆå³ä¾§è§†é¢‘å»¶è¿Ÿ/æå‰ç§’æ•°ï¼‰ï¼š</label>
                <input id="offsetRange" type="range" min="-5" max="5" step="0.1" value="0" />
                <input id="offsetValue" type="number" step="0.1" value="0" />
                <span id="offsetLabel">0.0s</span>
            </div>
        </div>

        <div class="controls-panel">
            <div class="control-group">
                <h3>â±ï¸ æ’­æ”¾é€Ÿåº¦</h3>
                <div class="speed-buttons">
                    <button class="btn" data-speed="0.5">0.5x</button>
                    <button class="btn" data-speed="0.75">0.75x</button>
                    <button class="btn active" data-speed="1.0">1.0x</button>
                    <button class="btn" data-speed="1.25">1.25x</button>
                    <button class="btn" data-speed="1.5">1.5x</button>
                </div>
            </div>

            <div class="control-group" style="margin-top:12px;">
                <h3>ğŸª é•œé¢ç¿»è½¬</h3>
                <button class="btn" id="mirrorOriginal">ç¿»è½¬åŸè§†é¢‘</button>
                <button class="btn" id="mirrorUser">ç¿»è½¬å½•åˆ¶è§†é¢‘</button>
            </div>

            <div class="control-group" style="margin-top:12px;">
                <h3>ğŸ”„ AB å¾ªç¯ï¼ˆä¸»æ§ï¼‰</h3>
                <button class="btn btn-secondary" id="setA">è®¾ç½® A ç‚¹</button>
                <button class="btn btn-secondary" id="setB">è®¾ç½® B ç‚¹</button>
                <button class="btn btn-success" id="startLoop">å¼€å§‹å¾ªç¯</button>
                <button class="btn" id="clearLoop">æ¸…é™¤å¾ªç¯</button>
                <div class="ab-loop-info" id="abInfo">A: æœªè®¾ç½® | B: æœªè®¾ç½®</div>
            </div>
        </div>

        <h2>ğŸ“¹ è§†é¢‘åˆ—è¡¨</h2>
        <div class="video-list" id="videoList">
            <p style="text-align:center; color:#666;">åŠ è½½ä¸­...</p>
        </div>
    </div>

    <!-- è£å‰ªé¢æ¿ï¼ˆå½•åˆ¶æˆ–æœ¬åœ°è§†é¢‘åŠ è½½åå¯æ‰“å¼€ï¼‰ -->
    <div id="cropPanel" class="crop-panel hidden" aria-hidden="true">
        <div class="crop-close" id="cropClose">âœ–</div>
        <h3>ğŸ¬ è£å‰ªå·²å½•åˆ¶/æœ¬åœ°è§†é¢‘</h3>
        <div class="preset-ratios" style="margin-top:8px;">
            <button class="ratio-btn active" data-ratio="16:9">16:9</button>
            <button class="ratio-btn" data-ratio="4:3">4:3</button>
            <button class="ratio-btn" data-ratio="1:1">1:1</button>
            <button class="ratio-btn" data-ratio="9:16">9:16</button>
            <button class="ratio-btn" data-ratio="custom">è‡ªå®šä¹‰</button>
        </div>
        <div class="crop-preview">
            <canvas id="cropCanvas" width="1280" height="720"></canvas>
            <div style="margin-top:8px; font-size:13px; color:#666;">æç¤ºï¼šå½“å‰å®ç°å¯¼å‡ºè£å‰ªåçš„é™æ€å¸§ï¼ˆPNGï¼‰ã€‚å¦‚éœ€å¯¼å‡ºè£å‰ªåçš„è§†é¢‘ï¼Œå¯é›†æˆ ffmpeg.wasmã€‚</div>
        </div>
        <div class="crop-actions">
            <button id="applyCropBtn" class="btn btn-success">âœ… åº”ç”¨è£å‰ªå¹¶ä¸‹è½½</button>
            <button id="cancelCropBtn" class="btn">å–æ¶ˆ</button>
        </div>
    </div>

    <script src="/static/js/utils.js"></script>
    <script src="/static/js/api.js"></script>
    <script>
        // elements
        const originalVideo = document.getElementById('originalVideo');
        const userVideo = document.getElementById('userVideo');
        const offsetRange = document.getElementById('offsetRange');
        const offsetValue = document.getElementById('offsetValue');
        const offsetLabel = document.getElementById('offsetLabel');
        const recTimer = document.getElementById('recTimer');

        let syncOffset = 0;
        let pointA = null, pointB = null;
        let currentVideoId = null;
        let mediaRecorder = null, recordedChunks = [], recordedBlob = null;
        let recStartTime = 0, recTimerInterval = null;

        // cropper state
        const cropPanel = document.getElementById('cropPanel');
        const cropCanvas = document.getElementById('cropCanvas');
        let activeCropper = null;

        // utils
        function showMessage(text, type='info', timeout=3000) { Utils.showMessage('message', text, type, timeout); }

        window.onload = function() {
            if (!DanceMirrorAPI.isLoggedIn()) {
                showMessage('è¯·å…ˆç™»å½•ï¼Œæ­£åœ¨è·³è½¬...', 'error', 1500);
                setTimeout(()=>location.href='/static/index.html', 1500);
                return;
            }
            initSyncControls();
            initRecordingControls();
            initModeSwitcher();
            initLocalUpload();
            initMiscControls();
            loadVideos();
        };

        // ---------- sync controls ----------
        function initSyncControls(){
            offsetRange.addEventListener('input', (e)=>{ syncOffset = parseFloat(e.target.value); offsetValue.value = syncOffset; offsetLabel.textContent = syncOffset.toFixed(1)+'s'; });
            offsetValue.addEventListener('change', (e)=>{ syncOffset = parseFloat(e.target.value)||0; offsetRange.value = syncOffset; offsetLabel.textContent = syncOffset.toFixed(1)+'s'; });
            document.getElementById('masterPlay').addEventListener('click', ()=> originalVideo.play());
            document.getElementById('masterPause').addEventListener('click', ()=> originalVideo.pause());
            document.getElementById('masterRestart').addEventListener('click', ()=> { originalVideo.currentTime = 0; syncUserVideoTime(); });
            originalVideo.addEventListener('play', ()=> { try { if (userVideo.src) userVideo.play(); } catch(e){} });
            originalVideo.addEventListener('pause', ()=> { try{ userVideo.pause(); }catch(e){} });
            originalVideo.addEventListener('seeked', ()=> syncUserVideoTime());
            originalVideo.addEventListener('timeupdate', ()=> syncUserVideoTime());
        }

        function syncUserVideoTime(){
            if (!userVideo.src || userVideo.readyState < 2) return;
            const target = originalVideo.currentTime + syncOffset;
            const clamped = Math.max(0, Math.min(userVideo.duration || Infinity, target));
            if (Math.abs(userVideo.currentTime - clamped) > 0.2) {
                try { userVideo.currentTime = clamped; } catch(e){ console.log('sync err', e); }
            }
        }

        // ---------- recording controls ----------
        function initRecordingControls(){
            document.getElementById('startRecBtn').addEventListener('click', startRecording);
            document.getElementById('stopRecBtn').addEventListener('click', stopRecording);
            document.getElementById('downloadRecBtn').addEventListener('click', downloadRecording);
            document.getElementById('uploadRecBtn').addEventListener('click', uploadRecording);
        }

        async function startRecording(){
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
                recordedChunks = [];
                const options = { mimeType: 'video/webm;codecs=vp8,opus' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) options.mimeType = 'video/webm';
                mediaRecorder = new MediaRecorder(stream, options);
                mediaRecorder.ondataavailable = e => { if (e.data && e.data.size>0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = () => {
                    stream.getTracks().forEach(t=>t.stop());
                    recordedBlob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(recordedBlob);
                    userVideo.srcObject = null;
                    userVideo.src = url;
                    userVideo.muted = false;
                    userVideo.load();
                    document.getElementById('downloadRecBtn').disabled = false;
                    document.getElementById('uploadRecBtn').disabled = false;
                    showMessage('å½•åˆ¶å®Œæˆï¼Œå¯æ’­æ”¾ã€ä¸‹è½½æˆ–ä¸Šä¼ ', 'success', 3000);
                };
                mediaRecorder.start();
                recStartTime = Date.now();
                startRecordingTimer();
                userVideo.srcObject = stream;
                userVideo.muted = true;
                userVideo.play();
                document.getElementById('startRecBtn').disabled = true;
                document.getElementById('startRecBtn').innerHTML = '<span class="recording-indicator"></span> å½•åˆ¶ä¸­...';
                document.getElementById('stopRecBtn').disabled = false;
                showMessage('å½•åˆ¶å·²å¼€å§‹', 'info', 1200);
            } catch (err) {
                showMessage('æ— æ³•è®¿é—®æ‘„åƒå¤´/éº¦å…‹é£: ' + (err.message||err), 'error', 4000);
                console.error(err);
            }
        }

        function stopRecording(){
            if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
            stopRecordingTimer();
            document.getElementById('startRecBtn').disabled = false;
            document.getElementById('startRecBtn').innerHTML = 'ğŸ”´ å¼€å§‹å½•åˆ¶';
            document.getElementById('stopRecBtn').disabled = true;
            // æ‰“å¼€è£å‰ªé¢æ¿ï¼ˆå¦‚æœæœ‰å½•åˆ¶æ–‡ä»¶æˆ–æœ¬åœ°è§†é¢‘ï¼‰
            setTimeout(()=> {
                if (recordedBlob || userVideo.src) openCropPanel();
            }, 200);
        }

        function startRecordingTimer(){
            recTimer.textContent = '0:00';
            recTimerInterval = setInterval(()=>{
                const elapsed = Math.floor((Date.now() - recStartTime)/1000);
                const mins = Math.floor(elapsed/60), secs = elapsed%60;
                recTimer.textContent = mins + ':' + String(secs).padStart(2,'0');
            }, 500);
        }
        function stopRecordingTimer(){ if (recTimerInterval) { clearInterval(recTimerInterval); recTimerInterval = null; } }

        function downloadRecording(){
            if (!recordedBlob) { showMessage('æ²¡æœ‰å¯ä¸‹è½½çš„å½•åˆ¶', 'error', 2000); return; }
            const url = URL.createObjectURL(recordedBlob);
            const a = document.createElement('a'); a.href = url; a.download = 'recording_' + Date.now() + '.webm'; document.body.appendChild(a); a.click(); a.remove();
            URL.revokeObjectURL(url);
            showMessage('ä¸‹è½½å·²å¼€å§‹', 'success', 1500);
        }

        async function uploadRecording(){
            const file = recordedBlob instanceof File ? recordedBlob : (recordedBlob ? new File([recordedBlob], 'recording_' + Date.now() + '.webm', { type: recordedBlob.type }) : null);
            if (!file) { showMessage('æ²¡æœ‰å¯ä¸Šä¼ çš„å½•åˆ¶', 'error', 2000); return; }
            try {
                showMessage('æ­£åœ¨ä¸Šä¼ ...', 'info');
                await DanceMirrorAPI.uploadVideo(file, { title: 'å½•åˆ¶_' + new Date().toLocaleString(), description: 'ç”¨æˆ·å½•åˆ¶è§†é¢‘' });
                showMessage('ä¸Šä¼ æˆåŠŸ', 'success', 2000);
                setTimeout(()=> loadVideos(), 500);
            } catch (err) {
                console.error(err);
                showMessage('ä¸Šä¼ å¤±è´¥: ' + (err.message||err), 'error', 4000);
            }
        }

        // ---------- video list ----------
        async function loadVideos(){
            const listEl = document.getElementById('videoList');
            try {
                const videos = await DanceMirrorAPI.getVideos();
                if (videos && videos.length) {
                    listEl.innerHTML = '';
                    videos.forEach((video, idx) => {
                        const item = document.createElement('div'); item.className = 'video-item';
                        item.innerHTML = '<h4>' + Utils.escapeHtml(video.title) + '</h4><p>' + Utils.escapeHtml(video.description || 'æš‚æ— æè¿°') + '</p><p style="font-size:11px;color:#999;margin-top:6px;">' + Utils.formatDate(video.createdAt) + '</p>';
                        item.onclick = ()=> selectVideo(video, item);
                        listEl.appendChild(item);
                        if (idx===0) selectVideo(video, item);
                    });
                } else {
                    listEl.innerHTML = '<p style="text-align:center;color:#666;">æš‚æ— è§†é¢‘</p>';
                }
            } catch (err) {
                console.error(err);
                showMessage('åŠ è½½å¤±è´¥: ' + (err.message||err), 'error');
                listEl.innerHTML = '<p style="text-align:center;color:#666;">åŠ è½½å¤±è´¥</p>';
            }
        }

        function selectVideo(video, itemEl){
            currentVideoId = video.id;
            // video.filePath å¯èƒ½æ˜¯ç›¸å¯¹è·¯å¾„ï¼Œç¡®ä¿ä»¥ / å¼€å¤´
            originalVideo.src = (video.filePath && video.filePath.startsWith('/')) ? video.filePath : '/' + (video.filePath || '');
            originalVideo.load();
            document.getElementById('videoTitle').textContent = video.title || 'æœªå‘½å';
            document.getElementById('videoDescription').textContent = video.description || 'æš‚æ— æè¿°';
            document.querySelectorAll('.video-item').forEach(i=>i.classList.remove('active'));
            if (itemEl) itemEl.classList.add('active');
            clearABLoop();
        }

        // ---------- mode switcher ----------
        function initModeSwitcher(){
            const sm = document.getElementById('singleModeBtn'), cm = document.getElementById('comparisonModeBtn');
            const single = document.getElementById('singleVideoContainer'), compare = document.getElementById('comparisonContainer');
            sm.addEventListener('click', ()=> {
                single.classList.remove('hidden'); compare.classList.add('hidden');
                const svid = document.getElementById('singleVideo');
                if (originalVideo.src) { svid.src = originalVideo.src; svid.load(); document.getElementById('singleVideoTitle').textContent = document.getElementById('videoTitle').textContent; }
            });
            cm.addEventListener('click', ()=> { single.classList.add('hidden'); compare.classList.remove('hidden'); });
        }

        // ---------- local upload ----------
        function initLocalUpload(){
            const fileInput = document.getElementById('localVideoInput'), uploadBtn = document.getElementById('uploadLocalBtn');
            uploadBtn.addEventListener('click', ()=> fileInput.click());
            fileInput.addEventListener('change', (e)=> {
                const f = e.target.files && e.target.files[0];
                if (!f) return;
                if (!f.type.startsWith('video/')) { showMessage('è¯·é€‰æ‹©è§†é¢‘æ–‡ä»¶', 'error'); return; }
                if (f.size > 524288000) { showMessage('æ–‡ä»¶å¤ªå¤§ï¼ˆ>500MBï¼‰', 'error'); return; }
                recordedBlob = f; // reuse recordedBlob for upload/download/cropping
                userVideo.srcObject = null; userVideo.src = URL.createObjectURL(f); userVideo.muted = false; userVideo.load();
                document.getElementById('downloadRecBtn').disabled = false; document.getElementById('uploadRecBtn').disabled = false;
                showMessage('æœ¬åœ°è§†é¢‘å·²åŠ è½½ï¼Œå¯ç”¨äºå¯¹æ¯”/è£å‰ª', 'success', 2000);
                // open crop panel optionally
                setTimeout(()=> openCropPanel(), 200);
            });
        }

        // ---------- misc controls ----------
        function initMiscControls(){
            document.querySelectorAll('.speed-buttons .btn').forEach(b => b.addEventListener('click', (e)=> {
                const s = parseFloat(b.dataset.speed || 1.0);
                originalVideo.playbackRate = s; userVideo.playbackRate = s;
                document.querySelectorAll('.speed-buttons .btn').forEach(x=>x.classList.remove('active'));
                b.classList.add('active');
                showMessage('æ’­æ”¾é€Ÿåº¦: ' + s + 'x', 'success', 1200);
            }));
            document.getElementById('mirrorOriginal').addEventListener('click', ()=> toggleMirror('original'));
            document.getElementById('mirrorUser').addEventListener('click', ()=> toggleMirror('user'));
            document.getElementById('setA').addEventListener('click', ()=> { pointA = originalVideo.currentTime; updateABInfo(); showMessage('A ç‚¹å·²è®¾ç½®: '+Utils.formatTime(pointA),'success'); });
            document.getElementById('setB').addEventListener('click', ()=> { pointB = originalVideo.currentTime; updateABInfo(); showMessage('B ç‚¹å·²è®¾ç½®: '+Utils.formatTime(pointB),'success'); });
            document.getElementById('startLoop').addEventListener('click', startABLoop);
            document.getElementById('clearLoop').addEventListener('click', clearABLoop);
        }

        function toggleMirror(target){
            const v = target==='original' ? originalVideo : userVideo;
            v.classList.toggle('mirrored');
            showMessage((target==='original'?'åŸè§†é¢‘':'å½•åˆ¶è§†é¢‘') + (v.classList.contains('mirrored') ? ' é•œåƒ: å¼€å¯' : ' é•œåƒ: å…³é—­'), 'success', 1200);
        }

        function startABLoop(){
            if (pointA===null || pointB===null) { showMessage('è¯·å…ˆè®¾ç½® A/B ç‚¹','error'); return; }
            if (pointA >= pointB) { showMessage('A å¿…é¡»å°äº B','error'); return; }
            originalVideo.currentTime = pointA; originalVideo.play();
            originalVideo.removeEventListener('timeupdate', handleABLoop); originalVideo.addEventListener('timeupdate', handleABLoop);
            showMessage('AB å¾ªç¯å·²å¼€å§‹', 'success', 1200);
        }
        function handleABLoop(){ if (originalVideo.currentTime >= pointB) originalVideo.currentTime = pointA; }
        function clearABLoop(){ pointA = pointB = null; originalVideo.removeEventListener('timeupdate', handleABLoop); updateABInfo(); showMessage('å·²æ¸…é™¤ AB å¾ªç¯','success',1000); }
        function updateABInfo(){ document.getElementById('abInfo').textContent = 'A: ' + (pointA!==null?Utils.formatTime(pointA):'æœªè®¾ç½®') + ' | B: ' + (pointB!==null?Utils.formatTime(pointB):'æœªè®¾ç½®'); }

        // keyboard shortcuts
        document.addEventListener('keydown', (e)=>{
            if (e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA') return;
            switch(e.code){
                case 'Space': e.preventDefault(); if (originalVideo.paused) originalVideo.play(); else originalVideo.pause(); break;
                case 'ArrowLeft': e.preventDefault(); originalVideo.currentTime = Math.max(0, originalVideo.currentTime - 5); break;
                case 'ArrowRight': e.preventDefault(); originalVideo.currentTime = Math.min(originalVideo.duration || 0, originalVideo.currentTime + 5); break;
                case 'KeyM': toggleMirror('original'); break;
                case 'KeyA': setPointA(); break;
                case 'KeyB': setPointB(); break;
                case 'KeyL': startABLoop(); break;
            }
        });

        // ---------- cropper (canvas-based, exports PNG frame) ----------
        class VideoCropper {
            constructor(videoEl, canvasEl){
                this.video = videoEl;
                this.canvas = canvasEl;
                this.ctx = canvasEl.getContext('2d');
                this.crop = null;
                this.raf = null;
            }
            init(){
                // fit canvas internal size to displayed width while keeping aspect
                this.resizeCanvas();
                window.addEventListener('resize', ()=> this.resizeCanvas());
                this.initRatioButtons();
                this.drawLoop();
            }
            resizeCanvas(){
                // keep internal resolution reasonably large for quality
                const rect = this.canvas.getBoundingClientRect();
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                this.canvas.width = Math.max(320, Math.round(rect.width * dpr));
                this.canvas.height = Math.max(180, Math.round(this.canvas.width * 9 / 16)); // default 16:9
                if (!this.crop) this.setRatio('16:9');
            }
            initRatioButtons(){
                document.querySelectorAll('.ratio-btn').forEach(b => b.addEventListener('click', (e)=>{
                    document.querySelectorAll('.ratio-btn').forEach(x=>x.classList.remove('active'));
                    b.classList.add('active');
                    this.setRatio(b.dataset.ratio);
                }));
            }
            setRatio(r){
                const [rw, rh] = r==='custom' ? [16,9] : r.split(':').map(Number);
                const w = this.canvas.width, h = this.canvas.height;
                const scale = Math.min(w / rw, h / rh);
                const cw = Math.round(rw * scale), ch = Math.round(rh * scale);
                this.crop = { x: Math.round((w - cw)/2), y: Math.round((h - ch)/2), w: cw, h: ch };
            }
            drawLoop(){
                if (this.video && this.video.readyState >= 2) {
                    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
                    // draw video scaled to canvas
                    this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                    if (this.crop) {
                        this.ctx.strokeStyle = '#00bfff'; this.ctx.lineWidth = Math.max(2, this.canvas.width * 0.002);
                        this.ctx.strokeRect(this.crop.x, this.crop.y, this.crop.w, this.crop.h);
                        this.ctx.fillStyle = 'rgba(0,191,255,0.06)';
                        this.ctx.fillRect(this.crop.x, this.crop.y, this.crop.w, this.crop.h);
                    }
                }
                this.raf = requestAnimationFrame(()=> this.drawLoop());
            }
            async exportCroppedImageBlob(){
                if (!this.crop) return null;
                const tmp = document.createElement('canvas');
                tmp.width = this.crop.w; tmp.height = this.crop.h;
                tmp.getContext('2d').drawImage(this.canvas, this.crop.x, this.crop.y, this.crop.w, this.crop.h, 0, 0, this.crop.w, this.crop.h);
                return new Promise(resolve => tmp.toBlob(resolve, 'image/png'));
            }
            destroy(){ cancelAnimationFrame(this.raf); window.removeEventListener('resize', ()=>{}); }
        }

        function openCropPanel(){
            cropPanel.classList.remove('hidden'); cropPanel.setAttribute('aria-hidden','false');
            // ensure video shown in userVideo is playing for frame capture
            userVideo.pause(); userVideo.currentTime = Math.min(userVideo.duration || 0, 0);
            setTimeout(()=> {
                userVideo.play().catch(()=>{});
                if (activeCropper) activeCropper.destroy();
                activeCropper = new VideoCropper(userVideo, cropCanvas);
                activeCropper.init();
            }, 200);
        }

        document.getElementById('applyCropBtn').addEventListener('click', async ()=>{
            if (!activeCropper) return;
            const blob = await activeCropper.exportCroppedImageBlob();
            if (!blob) { showMessage('è£å‰ªå¤±è´¥','error'); return; }
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'crop_' + Date.now() + '.png'; document.body.appendChild(a); a.click(); a.remove();
            URL.revokeObjectURL(url);
            showMessage('è£å‰ªå·²ä¿å­˜ï¼ˆPNGï¼‰ã€‚å¦‚éœ€å¯¼å‡ºè§†é¢‘è¯·è¯·æ±‚é›†æˆ ffmpeg.wasmã€‚', 'success', 3000);
            closeCropPanel();
        });

        document.getElementById('cancelCropBtn').addEventListener('click', ()=> closeCropPanel());
        document.getElementById('cropClose').addEventListener('click', ()=> closeCropPanel());

        function closeCropPanel(){
            cropPanel.classList.add('hidden'); cropPanel.setAttribute('aria-hidden','true');
            if (activeCropper) { activeCropper.destroy(); activeCropper = null; }
            try { userVideo.pause(); } catch(e){}
        }

        // ---------- keyboard and misc ----------
        function setPointA(){ pointA = originalVideo.currentTime; updateABInfo(); showMessage('A ç‚¹å·²è®¾ç½®: '+Utils.formatTime(pointA),'success'); }
        function setPointB(){ pointB = originalVideo.currentTime; updateABInfo(); showMessage('B ç‚¹å·²è®¾ç½®: '+Utils.formatTime(pointB),'success'); }
        function updateABInfo(){ document.getElementById('abInfo').textContent = 'A: ' + (pointA!==null?Utils.formatTime(pointA):'æœªè®¾ç½®') + ' | B: ' + (pointB!==null?Utils.formatTime(pointB):'æœªè®¾ç½®'); }

        // Lightweight helper to load ffmpeg.wasm (CDN) and run a crop+transcode command.
        // Usage:
        //   await ensureFFmpeg();
        //   const outBlob = await cropAndTranscode(recordedBlob, {x,y,w,h}, { format: 'mp4', onProgress: p => console.log(p) });

        async function loadScript(url) {
            return new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = url;
                s.onload = resolve;
                s.onerror = reject;
                document.head.appendChild(s);
            });
        }

        let _ffmpeg = null;
        let _ffmpegLoaded = false;

        async function ensureFFmpeg({ log=false } = {}) {
            if (window.createFFmpeg && window.fetchFile) {
                // bundle already loaded via other script
            } else {
                // load distribution from unpkg (pin version as needed)
                await loadScript('https://unpkg.com/@ffmpeg/ffmpeg@0.11.7/dist/ffmpeg.min.js');
            }

            if (!_ffmpeg) {
                const { createFFmpeg, fetchFile } = FFmpeg; // global provided by ffmpeg.min.js
                _ffmpeg = createFFmpeg({ log: !!log, corePath: 'https://unpkg.com/@ffmpeg/core@0.11.1/dist/ffmpeg-core.js' });
            }

            if (!_ffmpegLoaded) {
                await _ffmpeg.load(); // ä¸‹è½½ wasm core ç­‰ï¼Œå¯èƒ½å‡ å MBï¼Œè€—æ—¶
                _ffmpegLoaded = true;
            }

            return _ffmpeg;
        }

        /**
         * Crop + transcode input Blob using ffmpeg.wasm.
         * @param {Blob} inputBlob  åŸå§‹è§†é¢‘ Blob (webm/mp4...)
         * @param {{x:number,y:number,w:number,h:number}} crop  è£å‰ªåŒºåŸŸï¼ˆåƒç´ ï¼ŒåŸºäº canvas å†…éƒ¨åƒç´ å°ºå¯¸ï¼‰
         * @param {{format?:'mp4'|'webm', onProgress?:(ratio)=>void}} opts
         * @returns {Blob} è½¬ç åçš„ Blob
         */
        async function cropAndTranscode(inputBlob, crop, opts = {}) {
            const ffmpeg = await ensureFFmpeg({ log: false });
            const { fetchFile } = FFmpeg;
            const format = opts.format || 'mp4';
            const inputName = 'in.webm';
            const outputName = format === 'mp4' ? 'out.mp4' : 'out.webm';

            if (typeof opts.onProgress === 'function') {
                ffmpeg.setProgress(({ ratio }) => {
                    try { opts.onProgress(Math.min(1, Math.max(0, ratio))); } catch(e){ console.warn(e); }
                });
            }

            // write input file (fetchFile converts Blob->Uint8Array)
            ffmpeg.FS('writeFile', inputName, await fetchFile(inputBlob));

            // build crop filter string
            const vf = `crop=${crop.w}:${crop.h}:${crop.x}:${crop.y}`;

            // choose codec args (keep reasonable defaults)
            const codecArgs = format === 'mp4'
                ? ['-c:v','libx264','-preset','veryfast','-crf','23','-c:a','aac','-b:a','128k']
                : ['-c:v','libvpx-vp9','-b:v','1M','-c:a','libvorbis'];

            // run ffmpeg: input -> crop -> encode
            // Note: this can be extended for scaling, fps, filters etc.
            const args = ['-i', inputName, '-vf', vf, ...codecArgs, outputName];

            // Run ffmpeg (may take long on large videos and is CPU/memory heavy)
            await ffmpeg.run(...args);

            // read result
            const data = ffmpeg.FS('readFile', outputName);
            const outBlob = new Blob([data.buffer], { type: format === 'mp4' ? 'video/mp4' : 'video/webm' });

            // cleanup to free wasm FS
            try {
                ffmpeg.FS('unlink', inputName);
                ffmpeg.FS('unlink', outputName);
            } catch (e) {}

            return outBlob;
        }

        // export helpers to global for easy use in page scripts
        window.FFmpegWASM = { ensureFFmpeg, cropAndTranscode };
    </script>
</body>
</html>